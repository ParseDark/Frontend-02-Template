### 1. proxy与双向绑定 | proxy的基本用法
proxy， 就是对对象进行一个拦截， 并且赋予我们修改原生行为的机会。也就是在使用者和原生对象之间，插入了一个hook， 给予我们更为强大的能力。但同时也很危险。可能让你的code失去预期效果（由于你改变了它原来的行为）。所以proxy一般是提供给库的作者使用的。

### 2. proxy与双向绑定 | 模仿reactive实现原理（一）
实现数据响应的第一步是拦截。我们可以通过proxy， 对对象field的读写进行拦截。

### 3. proxy与双向绑定 | 模仿reactive实现原理（二）
实现数据响应的第二步是依赖收集。 我们通过effect触发proxy上的get方法， 同时在get方法里进行依赖的收集， 把effect中需要响应的代码根据字段名称放入依赖中。

第三步， 触发依赖更新， 在用户触发set行为的时候， 通过字段名称， 去触发对应的依赖方法。

### 4. proxy与双向绑定 | 模仿reactive实现原理（三）
通过以上的两步， 我们完成一个基本的响应式的编写。 但是此时还没法处理嵌套字段的依赖收集。 在这一步我们需要在get的hook中， 对字段的值进行判定。如果是对象， 那么通过递归去完成内部字段的依赖收集。同时在reactive函数中进行一个缓存的处理。

### 6. proxy与双向绑定 | reactivity响应式对象
通过以上步骤， 我们完成了一个较为健全的reactivity. 此时我们可以利用这个reactivity对象进行数据双向绑定的实践。基本思路在于。在effect中写需要更新dom的代码，在dom的事件监听中， 去proxy对象上触发set方法， 从而达到双向绑定的目的。

### 7. 使用Range实现DOM精确操作 | 基本拖拽
有几个关键点需要注意：
1. mousedown 之后再触发后续事件监听
2. 在document对象上监听move和up事件， 而不是mousedown的dom对象上。因为当鼠标移动速度过快， 会导致没办法监听到move事件和up事件（因为已经移出mousedown的dom了）
3. 初始位的记录， 我们要一个模块变量进行记录触发拖拽事件的初始位， 否则在之后的计算中会导致计算偏差。


### 8. 使用Range实现DOM精确操作 | 正常流里的拖拽
虽然跟着代码写出来了， 但是rang事件还是得重新了解一下。

